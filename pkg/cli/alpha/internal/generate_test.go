/*
Copyright 2025 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package internal

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"sigs.k8s.io/kubebuilder/v4/pkg/config"
	"sigs.k8s.io/kubebuilder/v4/pkg/config/store"
	"sigs.k8s.io/kubebuilder/v4/pkg/model/resource"
	deployimagev1alpha1 "sigs.k8s.io/kubebuilder/v4/pkg/plugins/golang/deploy-image/v1alpha1"
	"sigs.k8s.io/kubebuilder/v4/test/e2e/utils"
)

type fakeConfig struct {
	config.Config
	pluginChain []string
	domain      string
	repo        string
	multigroup  bool
	resources   []resource.Resource
	pluginErr   error
	getResErr   error
	plugins     map[string]any
}

func (f *fakeConfig) GetPluginChain() []string { return f.pluginChain }
func (f *fakeConfig) GetDomain() string        { return f.domain }
func (f *fakeConfig) GetRepository() string    { return f.repo }
func (f *fakeConfig) IsMultiGroup() bool       { return f.multigroup }
func (f *fakeConfig) GetResources() ([]resource.Resource, error) {
	if f.getResErr != nil {
		return nil, f.getResErr
	}
	return f.resources, nil
}

func (f *fakeConfig) DecodePluginConfig(key string, _ any) error {
	if len(f.plugins) == 0 {
		return config.PluginKeyNotFoundError{Key: key}
	}
	if f.pluginErr != nil {
		return f.pluginErr
	}
	// Check if the specific key exists
	if _, exists := f.plugins[key]; !exists {
		return config.PluginKeyNotFoundError{Key: key}
	}
	return nil
}

type fakeStore struct {
	store.Store
	cfg *fakeConfig
}

func (f *fakeStore) Config() config.Config { return f.cfg }

func TestGenerateHelpers(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Generate helpers Suite")
}

// setupKubebuilderMockEnvironment sets up a mock for kubebuilder testing
func setupKubebuilderMockEnvironment(kbc *utils.TestContext) string {
	// Save current working directory for restoration
	originalDir, err := os.Getwd()
	Expect(err).NotTo(HaveOccurred())

	// Create a PROJECT file in the test directory with proper YAML format
	projectFilePath := filepath.Join(kbc.Dir, "PROJECT")
	projectFileContent := []byte(`# Code generated by tool. DO NOT EDIT.
# This file is used to track the info used to scaffold your project
# and allow the plugins properly work.
# More info: https://book.kubebuilder.io/reference/project-config.html
domain: example.com
layout:
- go.kubebuilder.io/v4
projectName: test-project
repo: github.com/example/test-project
version: "3"
`)
	Expect(os.WriteFile(projectFilePath, projectFileContent, 0o644)).To(Succeed())

	// Create mock kubebuilder binary
	mockKubebuilderPath := filepath.Join(kbc.Dir, "kubebuilder")
	mockScript := `#!/bin/bash
# Log all commands to a file for debugging
log_file="` + filepath.Join(kbc.Dir, "kubebuilder.log") + `"
echo "$@" >> "$log_file"

if [[ "$1" == "init" ]]; then
	echo "kubebuilder init mock executed"
	exit 0
elif [[ "$1" == "create" && "$2" == "api" ]]; then
	echo "kubebuilder create api mock executed"
	exit 0
elif [[ "$1" == "create" && "$2" == "webhook" ]]; then
	echo "kubebuilder create webhook mock executed"
	exit 0
elif [[ "$1" == "edit" ]]; then
	echo "kubebuilder edit mock executed"
	exit 0
else
	echo "kubebuilder mock executed with args: $@"
	exit 0
fi`
	Expect(os.WriteFile(mockKubebuilderPath, []byte(mockScript), 0o755)).To(Succeed())

	// Create mock make binary
	mockMakePath := filepath.Join(kbc.Dir, "make")
	makeScript := `#!/bin/bash
	# Log all commands to a file for debugging
	log_file="` + filepath.Join(kbc.Dir, "make.log") + `"
	echo "$@" >> "$log_file"
	echo "make mock executed with target: $@"
	exit 0`
	Expect(os.WriteFile(mockMakePath, []byte(makeScript), 0o755)).To(Succeed())

	// Add the test directory to PATH so the mock binaries are found
	oldPath := os.Getenv("PATH")
	newPath := fmt.Sprintf("%s:%s", kbc.Dir, oldPath)
	Expect(os.Setenv("PATH", newPath)).To(Succeed())

	// Change to the test directory so kubebuilder can find the PROJECT file
	Expect(os.Chdir(kbc.Dir)).To(Succeed())

	// Return the original directory for restoration
	return originalDir
}

var _ = Describe("generate: validate", func() {
	var (
		kbc *utils.TestContext
		err error
	)

	BeforeEach(func() {
		// Initialize TestContext
		kbc, err = utils.NewTestContext("kubebuilder", "GO111MODULE=on")
		Expect(err).NotTo(HaveOccurred())
		Expect(kbc.Prepare()).To(Succeed())

		// Create a PROJECT file in the test directory
		projectFilePath := filepath.Join(kbc.Dir, "PROJECT")
		projectFileContent := []byte("domain: example.com\nrepo: github.com/example/repo\n")
		Expect(os.WriteFile(projectFilePath, projectFileContent, 0o644)).To(Succeed())
	})

	AfterEach(func() {
		By("cleaning up test artifacts")
		kbc.Destroy()
	})

	// Validate
	Context("Validate", func() {
		Context("Success", func() {
			It("succeeds", func() {
				g := &Generate{InputDir: kbc.Dir}
				Expect(g.Validate()).To(Succeed())
			})
		})

		Context("Failure", func() {
			It("returns error if GetInputPath fails", func() {
				g := &Generate{InputDir: filepath.Join(kbc.Dir, "notfound")}
				Expect(g.Validate()).NotTo(Succeed())
			})
		})
	})
})

var _ = Describe("generate: directory-helpers", func() {
	var (
		tmpDir string
		err    error
	)
	BeforeEach(func() {
		tmpDir, err = os.MkdirTemp("", "testdir")
		Expect(err).NotTo(HaveOccurred())
	})
	AfterEach(func() {
		Expect(os.RemoveAll(tmpDir)).To(Succeed())
	})

	// createDirectory
	Context("createDirectory", func() {
		It("creates directory successfully", func() {
			dir := filepath.Join(tmpDir, "testdir-generate-go")
			Expect(createDirectory(dir)).To(Succeed())
			_, err = os.Stat(dir)
			Expect(err).NotTo(HaveOccurred())
		})
		It("returns error for invalid path", func() {
			Expect(createDirectory("/dev/null/foo")).NotTo(Succeed())
		})
	})

	// changeWorkingDirectory
	Context("changeWorkingDirectory", func() {
		var originalDir string

		BeforeEach(func() {
			// Save current working directory
			originalDir, err = os.Getwd()
			Expect(err).NotTo(HaveOccurred())
		})

		AfterEach(func() {
			// Restore original working directory
			Expect(os.Chdir(originalDir)).To(Succeed())
		})

		It("changes working directory successfully", func() {
			// Create a test file in the target directory to verify we can access it after changing
			testFile := filepath.Join(tmpDir, "test-file.txt")
			testContent := "test content"
			Expect(os.WriteFile(testFile, []byte(testContent), 0o644)).To(Succeed())

			// Change to the directory
			Expect(changeWorkingDirectory(tmpDir)).To(Succeed())

			// Verify we're in the correct directory by checking we can read the file
			// using relative path (this proves we're in the right directory)
			content, err := os.ReadFile("test-file.txt")
			Expect(err).NotTo(HaveOccurred())
			Expect(string(content)).To(Equal(testContent))

			// Also verify we can create a new file in the current directory
			newFile := "new-test-file.txt"
			newContent := "new content"
			Expect(os.WriteFile(newFile, []byte(newContent), 0o644)).To(Succeed())

			// Verify the file was created in the expected location
			fullPath := filepath.Join(tmpDir, newFile)
			verifyContent, err := os.ReadFile(fullPath)
			Expect(err).NotTo(HaveOccurred())
			Expect(string(verifyContent)).To(Equal(newContent))
		})

		It("returns error for non-existent directory", func() {
			nonExistentDir := filepath.Join(tmpDir, "nonexistent")
			Expect(changeWorkingDirectory(nonExistentDir)).NotTo(Succeed())
		})

		It("returns error for invalid path", func() {
			Expect(changeWorkingDirectory("/dev/null/foo")).NotTo(Succeed())
		})
	})
})

var _ = Describe("generate: file-helpers", func() {
	var (
		tmpDir string
		err    error
	)
	BeforeEach(func() {
		tmpDir, err = os.MkdirTemp("", "testdir")
		Expect(err).NotTo(HaveOccurred())
	})
	AfterEach(func() {
		Expect(os.RemoveAll(tmpDir)).To(Succeed())
	})

	// copyFile
	Context("copyFile", func() {
		Context("success", func() {
			var src, dst string
			BeforeEach(func() {
				src = filepath.Join(tmpDir, "src.txt")
				dst = filepath.Join(tmpDir, "dst.txt")
				Expect(os.WriteFile(src, []byte("hello"), 0o644)).To(Succeed())
			})
			AfterEach(func() {
				Expect(os.Remove(src)).To(Succeed())
				Expect(os.Remove(dst)).To(Succeed())
			})

			It("copies file successfully", func() {
				Expect(copyFile(src, dst)).To(Succeed())
				b, err := os.ReadFile(dst)
				Expect(err).NotTo(HaveOccurred())
				Expect(string(b)).To(Equal("hello"))
			})
		})

		Context("failure", func() {
			It("returns error if src does not exist", func() {
				src := filepath.Join(tmpDir, "notfound")
				dst := filepath.Join(tmpDir, "nowhere")
				Expect(copyFile(src, dst)).NotTo(Succeed())
			})
		})
	})
})

var _ = Describe("generate: get-args-helpers", func() {
	// getInitArgs
	Describe("getInitArgs", func() {
		Context("for outdated plugins", func() {
			When("v3 plugin is used", func() {
				It("should return correct args for plugins, domain, repo", func() {
					cfg := &fakeConfig{pluginChain: []string{"go.kubebuilder.io/v3"}, domain: "foo.com", repo: "bar"}
					store := &fakeStore{cfg: cfg}
					args := getInitArgs(store)
					Expect(args).To(ContainElements("--plugins", ContainSubstring("go.kubebuilder.io/v4"),
						"--domain", "foo.com", "--repo", "bar"))
				})
			})

			When("alpha plugin is used", func() {
				It("should return correct args for plugins, domain, repo", func() {
					cfg := &fakeConfig{pluginChain: []string{"go.kubebuilder.io/v3-alpha"}, domain: "foo.com", repo: "bar"}
					store := &fakeStore{cfg: cfg}
					args := getInitArgs(store)
					Expect(args).To(ContainElements("--plugins", ContainSubstring("go.kubebuilder.io/v4"),
						"--domain", "foo.com", "--repo", "bar"))
				})
			})
		})

		Context("for latest plugins", func() {
			When("latest plugin (v4) is used", func() {
				It("returns correct args for plugins, domain, repo", func() {
					cfg := &fakeConfig{pluginChain: []string{"go.kubebuilder.io/v4"}, domain: "foo.com", repo: "bar"}
					store := &fakeStore{cfg: cfg}
					args := getInitArgs(store)
					Expect(args).To(ContainElements("--plugins", ContainSubstring("go.kubebuilder.io/v4"),
						"--domain", "foo.com", "--repo", "bar"))
				})
			})
		})
	})

	// getGVKFlags
	Context("getGVKFlags", func() {
		It("returns correct flags", func() {
			res := resource.Resource{Plural: "foos"}
			res.Group = "example.com"
			res.Version = "v1"
			res.Kind = "Foo"
			flags := getGVKFlags(res)
			Expect(flags).To(ContainElements("--plural", "foos", "--group", "example.com", "--version", "v1", "--kind", "Foo"))
		})
	})

	// getGVKFlagsFromDeployImage
	Context("getGVKFlagsFromDeployImage", func() {
		It("returns correct flags", func() {
			rd := deployimagev1alpha1.ResourceData{Group: "example.com", Version: "v1", Kind: "Foo"}
			flags := getGVKFlagsFromDeployImage(rd)
			Expect(flags).To(ContainElements("--group", "example.com", "--version", "v1", "--kind", "Foo"))
		})
	})

	// getDeployImageOptions
	Context("getDeployImageOptions", func() {
		It("returns correct options", func() {
			rd := deployimagev1alpha1.ResourceData{}
			rd.Options.Image = "test-kubebuilder"
			rd.Options.ContainerCommand = "echo 'Hello'"
			rd.Options.ContainerPort = "8000"
			rd.Options.RunAsUser = "test"
			opts := getDeployImageOptions(rd)
			Expect(opts).To(ContainElements("--image=test-kubebuilder",
				"--image-container-command=echo 'Hello'",
				"--image-container-port=8000",
				"--run-as-user=test",
				"--plugins=deploy-image.go.kubebuilder.io/v1-alpha"))
		})
	})

	// getAPIResourceFlags
	Context("getAPIResourceFlags", func() {
		var res resource.Resource
		BeforeEach(func() {
			res = resource.Resource{API: &resource.API{}}
		})

		Context("returns correct flags", func() {
			It("for nil API with Controller set", func() {
				res.Controller = true
				Expect(getAPIResourceFlags(res)).To(ContainElements("--resource=false", "--controller"))
			})
			It("for non nil API (namespaced not set) with Controller not set", func() {
				res.API.CRDVersion = "v1"
				res.API.Namespaced = true
				Expect(getAPIResourceFlags(res)).To(ContainElements("--resource", "--namespaced", "--controller=false"))
			})
			It("for non nil API (namespaced set) with Controller not set", func() {
				res.API.CRDVersion = "v1"
				res.API.Namespaced = false
				Expect(getAPIResourceFlags(res)).To(ContainElements("--resource", "--namespaced=false", "--controller=false"))
			})
		})
	})
	// getWebhookResourceFlags
	Context("getWebhookResourceFlags", func() {
		It("returns correct flags for specified resources", func() {
			res := resource.Resource{
				Path:     "external/test",
				GVK:      resource.GVK{Group: "example.com", Version: "v1", Kind: "Example", Domain: "test"},
				External: true,
				Webhooks: &resource.Webhooks{
					Validation: true,
					Defaulting: true,
					Conversion: true,
					Spoke:      []string{"v2"},
				},
			}
			flags := getWebhookResourceFlags(res)
			Expect(flags).To(ContainElements("--external-api-path", "external/test", "--external-api-domain", "test",
				"--programmatic-validation", "--defaulting", "--conversion", "--spoke", "v2"))
		})
	})
})

var _ = Describe("generate: create-helpers", func() {
	var (
		kbc         *utils.TestContext
		err         error
		originalDir string
	)

	BeforeEach(func() {
		// Initialize TestContext
		kbc, err = utils.NewTestContext("kubebuilder", "GO111MODULE=on")
		Expect(err).NotTo(HaveOccurred())
		Expect(kbc.Prepare()).To(Succeed())

		// Setup mock kubebuilder environment
		originalDir = setupKubebuilderMockEnvironment(kbc)
	})

	AfterEach(func() {
		By("cleaning up test artifacts")
		// Restore original working directory
		Expect(os.Chdir(originalDir)).To(Succeed())
		kbc.Destroy()
	})

	// createAPI
	Describe("createAPI", func() {
		Context("Without External flag", func() {
			It("runs kubebuilder create api successfully for a resource", func() {
				res := resource.Resource{
					GVK:        resource.GVK{Group: "example.com", Version: "v1", Kind: "Example", Domain: "test"},
					Plural:     "examples",
					API:        &resource.API{Namespaced: true},
					Controller: true,
				}
				// Run createAPI and verify no errors
				Expect(createAPI(res)).To(Succeed())
			})
		})

		Context("With External flag set", func() {
			It("runs kubebuilder create api successfully for a resource", func() {
				res := resource.Resource{
					GVK:        resource.GVK{Group: "example.com", Version: "v1", Kind: "Example", Domain: "external"},
					Plural:     "examples",
					API:        &resource.API{Namespaced: true},
					Controller: true,
					External:   true,
					Path:       "external/path",
				}
				// Run createAPI and verify no errors
				Expect(createAPI(res)).To(Succeed())
			})
		})
	})

	// createWebhook
	Describe("createWebhook", func() {
		It("runs kubebuilder create webhook successfully for a resource", func() {
			res := resource.Resource{
				GVK:      resource.GVK{Group: "example.com", Version: "v1", Kind: "Example", Domain: "test"},
				Plural:   "examples",
				Webhooks: &resource.Webhooks{WebhookVersion: "v1"},
			}
			// Run createWebhook and verify no errors
			Expect(createWebhook(res)).To(Succeed())
		})

		It("ignores web creation if webhook resource is empty", func() {
			res := resource.Resource{
				GVK:      resource.GVK{Group: "example.com", Version: "v1", Kind: "Example", Domain: "test"},
				Plural:   "examples",
				Webhooks: &resource.Webhooks{},
			}
			// Run createWebhook and verify no errors
			Expect(createWebhook(res)).To(Succeed())
		})
	})

	Describe("createAPIWithDeployImage", func() {
		It("runs kubebuilder create api successfully with deploy image", func() {
			resourceData := deployimagev1alpha1.ResourceData{
				Group:   "example.com",
				Version: "v1",
				Kind:    "Example",
			}
			resourceData.Options.Image = "example-image"
			resourceData.Options.ContainerCommand = "run"
			resourceData.Options.ContainerPort = "8080"
			resourceData.Options.Image = "test"
			// Run createAPIWithDeployImage and verify no errors
			Expect(createAPIWithDeployImage(resourceData)).To(Succeed())
		})
	})
})

var _ = Describe("generate: kubebuilder", func() {
	var (
		kbc                           *utils.TestContext
		err                           error
		originalDir                   string
		originalGetExecutablePathFunc func() (string, error)
	)

	BeforeEach(func() {
		// Save the original function
		originalGetExecutablePathFunc = getExecutablePathFunc

		// Initialize TestContext
		kbc, err = utils.NewTestContext("kubebuilder", "GO111MODULE=on")
		Expect(err).NotTo(HaveOccurred())
		Expect(kbc.Prepare()).To(Succeed())

		// Setup mock kubebuilder environment
		originalDir = setupKubebuilderMockEnvironment(kbc)

		// Mock getExecutablePathFunc to return the mock kubebuilder binary path
		getExecutablePathFunc = func() (string, error) {
			return filepath.Join(kbc.Dir, "kubebuilder"), nil
		}
	})

	AfterEach(func() {
		// Restore the original getExecutablePath function
		getExecutablePathFunc = originalGetExecutablePathFunc

		// Restore original working directory
		Expect(os.Chdir(originalDir)).To(Succeed())

		// Clean up test artifacts
		kbc.Destroy()
	})

	Context("kubebuilderInit", func() {
		It("runs kubebuilder init successfully", func() {
			cfg := &fakeConfig{
				pluginChain: []string{"go.kubebuilder.io/v4"},
				domain:      "example.com",
				repo:        "github.com/example/repo",
			}
			store := &fakeStore{cfg: cfg}
			Expect(kubebuilderInit(store)).To(Succeed())
		})
	})

	Context("kubebuilderCreate", func() {
		It("runs kubebuilder create successfully for resources", func() {
			cfg := &fakeConfig{
				resources: []resource.Resource{
					{Plural: "foos", GVK: resource.GVK{Group: "example.com", Version: "v1", Kind: "Foo"}},
					{Plural: "bars", GVK: resource.GVK{Group: "example.com", Version: "v1", Kind: "Bar"}},
				},
			}
			store := &fakeStore{cfg: cfg}
			// Run kubebuilderCreate and verify no errors
			Expect(kubebuilderCreate(store)).To(Succeed())
		})
	})

	Context("kubebuilderEdit", func() {
		It("runs kubebuilder edit successfully for multigroup layout", func() {
			cfg := &fakeConfig{multigroup: true}
			store := &fakeStore{cfg: cfg}
			// Run kubebuilderEdit and verify no errors
			Expect(kubebuilderEdit(store)).To(Succeed())
		})
	})

	Context("kubebuilderGrafanaEdit", func() {
		It("runs kubebuilder edit successfully for Grafana plugin", func() {
			// Run kubebuilderGrafanaEdit and verify no errors
			Expect(kubebuilderGrafanaEdit()).To(Succeed())
		})
	})

	Context("kubebuilderHelmEdit", func() {
		It("runs kubebuilder edit successfully for Helm plugin", func() {
			// Run kubebuilderHelmEdit and verify no errors
			Expect(kubebuilderHelmEdit(true)).To(Succeed())
		})
	})
})

var _ = Describe("generate: hasHelmPlugin", func() {
	It("returns true if v2-alpha plugin present", func() {
		cfg := &fakeConfig{plugins: map[string]any{"helm.kubebuilder.io/v2-alpha": true}}
		store := &fakeStore{cfg: cfg}
		hasPlugin, isV2Alpha := hasHelmPlugin(store)
		Expect(hasPlugin).To(BeTrue())
		Expect(isV2Alpha).To(BeTrue())
	})

	It("returns true if v1-alpha plugin present", func() {
		cfg := &fakeConfig{plugins: map[string]any{"helm.kubebuilder.io/v1-alpha": true}}
		store := &fakeStore{cfg: cfg}
		hasPlugin, isV2Alpha := hasHelmPlugin(store)
		Expect(hasPlugin).To(BeTrue())
		Expect(isV2Alpha).To(BeFalse())
	})

	It("returns false if both plugins not found", func() {
		cfg := &fakeConfig{pluginErr: &config.PluginKeyNotFoundError{Key: "helm.kubebuilder.io/v2-beta"}}
		store := &fakeStore{cfg: cfg}
		hasPlugin, isV2Alpha := hasHelmPlugin(store)
		Expect(hasPlugin).To(BeFalse())
		Expect(isV2Alpha).To(BeFalse())
	})
})

var _ = Describe("generate: migrate-plugins", func() {
	var (
		kbc         *utils.TestContext
		tmpDir      string
		err         error
		originalDir string
	)

	BeforeEach(func() {
		// Initialize TestContext
		kbc, err = utils.NewTestContext("kubebuilder", "GO111MODULE=on")
		Expect(err).NotTo(HaveOccurred())
		Expect(kbc.Prepare()).To(Succeed())

		// Setup mock kubebuilder environment
		originalDir = setupKubebuilderMockEnvironment(kbc)

		tmpDir = kbc.Dir
	})

	AfterEach(func() {
		By("cleaning up test artifacts")
		// Restore original working directory
		Expect(os.Chdir(originalDir)).To(Succeed())
		kbc.Destroy()
	})

	Context("migrateGrafanaPlugin", func() {
		It("skips migration as Grafana plugin not found", func() {
			cfg := &fakeConfig{pluginErr: &config.PluginKeyNotFoundError{Key: "grafana.kubebuilder.io/v1-alpha"}}
			store := &fakeStore{cfg: cfg}
			Expect(migrateGrafanaPlugin(store, "src", "dest")).To(Succeed())
		})

		It("returns error if decoding Grafana plugin config fails", func() {
			cfg := &fakeConfig{
				pluginErr: fmt.Errorf("decoding error"),
				plugins:   map[string]any{"grafana.kubebuilder.io/v1-alpha": true},
			}
			store := &fakeStore{cfg: cfg}
			Expect(migrateGrafanaPlugin(store, "src", "dest")).NotTo(Succeed())
		})

		Context("success", func() {
			var src, dest string
			BeforeEach(func() {
				src = filepath.Join(tmpDir, "src")
				dest = filepath.Join(tmpDir, "dest")
				Expect(os.MkdirAll(filepath.Join(src, "grafana/custom-metrics"), 0o755)).To(Succeed())
				Expect(os.WriteFile(filepath.Join(src, "grafana/custom-metrics/config.yaml"),
					[]byte("config"), 0o755)).To(Succeed())
				Expect(os.MkdirAll(filepath.Join(dest, "grafana/custom-metrics"), 0o755)).To(Succeed())
			})

			AfterEach(func() {
				Expect(os.RemoveAll(src)).To(Succeed())
				Expect(os.RemoveAll(dest)).To(Succeed())
			})

			It("migrates Grafana plugin successfully", func() {
				cfg := &fakeConfig{plugins: map[string]any{"grafana.kubebuilder.io/v1-alpha": true}}
				store := &fakeStore{cfg: cfg}
				Expect(migrateGrafanaPlugin(store, src, dest)).To(Succeed())
				b, err := os.ReadFile(filepath.Join(dest, "grafana/custom-metrics/config.yaml"))
				Expect(err).NotTo(HaveOccurred())
				Expect(string(b)).To(Equal("config"))
			})
		})
	})

	Context("migrateAutoUpdatePlugin", func() {
		It("skips migration as AutoUpdate plugin not found", func() {
			cfg := &fakeConfig{pluginErr: &config.PluginKeyNotFoundError{Key: "autoupdate.kubebuilder.io/v1-alpha"}}
			store := &fakeStore{cfg: cfg}
			Expect(migrateGrafanaPlugin(store, "src", "dest")).To(Succeed())
		})

		It("returns error if failed to decode Auto Update plugin", func() {
			cfg := &fakeConfig{
				pluginErr: fmt.Errorf("decoding error"),
				plugins:   map[string]any{"autoupdate.kubebuilder.io/v1-alpha": true},
			}
			store := &fakeStore{cfg: cfg}
			Expect(migrateAutoUpdatePlugin(store)).NotTo(Succeed())
		})

		It("migrates Auto Update plugin successfully", func() {
			cfg := &fakeConfig{plugins: map[string]any{"autoupdate.kubebuilder.io/v1-alpha": true}}
			store := &fakeStore{cfg: cfg}
			Expect(migrateAutoUpdatePlugin(store)).To(Succeed())
		})
	})

	Context("migrateDeployImagePlugin", func() {
		It("returns error if failed to decode Deploy Image plugin", func() {
			cfg := &fakeConfig{pluginErr: &config.PluginKeyNotFoundError{Key: "deploy-image.kubebuilder.io/v1-alpha"}}
			store := &fakeStore{cfg: cfg}
			Expect(migrateDeployImagePlugin(store)).To(Succeed())
		})

		It("returns error if decoding Deploy Image plugin config fails", func() {
			cfg := &fakeConfig{
				pluginErr: fmt.Errorf("decoding error"),
				plugins:   map[string]any{"deploy-image.kubebuilder.io/v1-alpha": true},
			}
			store := &fakeStore{cfg: cfg}
			Expect(migrateDeployImagePlugin(store)).NotTo(Succeed())
		})

		It("migrates Deploy Image plugin successfully", func() {
			cfg := &fakeConfig{plugins: map[string]any{"deploy-image.kubebuilder.io/v1-alpha": true}}
			store := &fakeStore{cfg: cfg}

			// Mock resources for the plugin
			resources := []deployimagev1alpha1.ResourceData{
				{
					Group:   "example.com",
					Version: "v1",
					Kind:    "Example",
				},
			}

			cfg.pluginChain = []string{"deploy-image.kubebuilder.io/v1-alpha"}
			store.cfg = cfg

			// Use the mocked resources
			for _, r := range resources {
				Expect(createAPIWithDeployImage(r)).To(Succeed())
			}
			Expect(migrateDeployImagePlugin(store)).To(Succeed())
		})
	})
})

var _ = Describe("Generate", func() {
	var (
		kbc                           *utils.TestContext
		err                           error
		g                             *Generate
		originalDir                   string
		originalGetExecutablePathFunc func() (string, error)
	)

	BeforeEach(func() {
		// Save the original function
		originalGetExecutablePathFunc = getExecutablePathFunc

		// Initialize TestContext
		kbc, err = utils.NewTestContext("kubebuilder", "GO111MODULE=on")
		Expect(err).NotTo(HaveOccurred())
		Expect(kbc.Prepare()).To(Succeed())

		// Setup mock kubebuilder environment
		originalDir = setupKubebuilderMockEnvironment(kbc)

		// Mock getExecutablePathFunc to return the mock kubebuilder binary path
		getExecutablePathFunc = func() (string, error) {
			return filepath.Join(kbc.Dir, "kubebuilder"), nil
		}

		// Initialize Generate
		g = &Generate{InputDir: kbc.Dir}
	})

	AfterEach(func() {
		// Restore the original getExecutablePath function
		getExecutablePathFunc = originalGetExecutablePathFunc

		// Restore original working directory
		Expect(os.Chdir(originalDir)).To(Succeed())

		By("cleaning up test artifacts")
		kbc.Destroy()
	})

	Context("outputDir is non empty", func() {
		It("scaffolds the project in output dir", func() {
			g.OutputDir = kbc.Dir
			Expect(g.Generate()).To(Succeed())
		})
	})
})
