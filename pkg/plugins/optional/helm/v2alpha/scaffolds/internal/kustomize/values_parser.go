/*
Copyright 2025 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package kustomize

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"go.yaml.in/yaml/v3"
)

// ValuesParser handles parsing and analyzing values.yaml files
type ValuesParser struct {
	outputDir string
}

// NewValuesParser creates a new values parser
func NewValuesParser(outputDir string) *ValuesParser {
	return &ValuesParser{
		outputDir: outputDir,
	}
}

// ParsedValues represents a parsed values.yaml structure
type ParsedValues struct {
	Raw  map[string]any
	Path string
}

// UserAddedValues represents values that were added by the user
// beyond the standard generated values
type UserAddedValues struct {
	// ManagerLabels are custom labels to add to the manager deployment
	ManagerLabels map[string]string
	// ManagerAnnotations are custom annotations to add to the manager deployment
	ManagerAnnotations map[string]string
	// ManagerPodLabels are custom labels to add to the manager pod
	ManagerPodLabels map[string]string
	// ManagerPodAnnotations are custom annotations to add to the manager pod
	ManagerPodAnnotations map[string]string
	// EnvVars are custom environment variables (manager.env)
	EnvVars []map[string]any
	// CustomManagerFields are any other custom fields added under manager.*
	CustomManagerFields map[string]any
	// CustomTopLevelFields are custom fields added at the root level
	CustomTopLevelFields map[string]any
}

// ParseExistingValues reads and parses existing values.yaml if it exists
func (p *ValuesParser) ParseExistingValues() (*ParsedValues, error) {
	valuesPath := filepath.Join(p.outputDir, "chart", "values.yaml")

	// Check if values.yaml exists
	if _, err := os.Stat(valuesPath); os.IsNotExist(err) {
		// File doesn't exist, return empty values
		return &ParsedValues{
			Raw:  make(map[string]any),
			Path: valuesPath,
		}, nil
	}

	// Read the file
	content, err := os.ReadFile(valuesPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read values.yaml: %w", err)
	}

	// Parse YAML
	var values map[string]any
	if err := yaml.Unmarshal(content, &values); err != nil {
		return nil, fmt.Errorf("failed to parse values.yaml: %w", err)
	}

	return &ParsedValues{
		Raw:  values,
		Path: valuesPath,
	}, nil
}

// DetectUserAddedValues compares parsed values against the standard schema
// to identify user-added customizations
func (p *ValuesParser) DetectUserAddedValues(parsed *ParsedValues) *UserAddedValues {
	result := &UserAddedValues{
		ManagerLabels:         make(map[string]string),
		ManagerAnnotations:    make(map[string]string),
		ManagerPodLabels:      make(map[string]string),
		ManagerPodAnnotations: make(map[string]string),
		EnvVars:               []map[string]any{},
		CustomManagerFields:   make(map[string]any),
		CustomTopLevelFields:  make(map[string]any),
	}

	if parsed.Raw == nil {
		return result
	}

	// Standard fields that are generated by default
	standardTopLevelFields := map[string]bool{
		"nameOverride":     true,
		"fullnameOverride": true,
		"manager":          true,
		"rbacHelpers":      true,
		"crd":              true,
		"metrics":          true,
		"certManager":      true,
		"webhook":          true,
		"prometheus":       true,
	}

	standardManagerFields := map[string]bool{
		"replicas":           true,
		"image":              true,
		"args":               true,
		"env":                true,
		"imagePullSecrets":   true,
		"podSecurityContext": true,
		"securityContext":    true,
		"resources":          true,
		"affinity":           true,
		"nodeSelector":       true,
		"tolerations":        true,
	}

	// Detect top-level custom fields
	for key, value := range parsed.Raw {
		if !standardTopLevelFields[key] {
			result.CustomTopLevelFields[key] = value
		}
	}

	// Detect manager-level custom fields
	if managerVal, ok := parsed.Raw["manager"].(map[string]any); ok {
		for key, value := range managerVal {
			if !standardManagerFields[key] {
				result.CustomManagerFields[key] = value
			}
		}

		// Check for special fields that we want to extract separately
		if labels, ok := managerVal["labels"].(map[string]any); ok {
			for k, v := range labels {
				if str, ok := v.(string); ok {
					result.ManagerLabels[k] = str
				}
			}
		}

		if annotations, ok := managerVal["annotations"].(map[string]any); ok {
			for k, v := range annotations {
				if str, ok := v.(string); ok {
					result.ManagerAnnotations[k] = str
				}
			}
		}

		if podLabels, ok := managerVal["podLabels"].(map[string]any); ok {
			for k, v := range podLabels {
				if str, ok := v.(string); ok {
					result.ManagerPodLabels[k] = str
				}
			}
		}

		if podAnnotations, ok := managerVal["podAnnotations"].(map[string]any); ok {
			for k, v := range podAnnotations {
				if str, ok := v.(string); ok {
					result.ManagerPodAnnotations[k] = str
				}
			}
		}

		// Check for env vars - since manager.env is a standard field handled by
		// existing helm_templater.go, we just extract them for tracking
		if envVal, ok := managerVal["env"].([]any); ok {
			for _, envItem := range envVal {
				if envMap, ok := envItem.(map[string]any); ok {
					result.EnvVars = append(result.EnvVars, envMap)
				}
			}
		}
	}

	return result
}

// GetStandardFieldPaths returns a map of standard field paths for validation
func GetStandardFieldPaths() map[string]bool {
	return map[string]bool{
		// Top level
		"nameOverride":     true,
		"fullnameOverride": true,

		// Manager
		"manager.replicas":           true,
		"manager.image.repository":   true,
		"manager.image.tag":          true,
		"manager.image.pullPolicy":   true,
		"manager.args":               true,
		"manager.env":                true,
		"manager.envFrom":            true,
		"manager.imagePullSecrets":   true,
		"manager.podSecurityContext": true,
		"manager.securityContext":    true,
		"manager.resources":          true,
		"manager.affinity":           true,
		"manager.nodeSelector":       true,
		"manager.tolerations":        true,
		"manager.volumes":            true,
		"manager.volumeMounts":       true,
		"manager.ports":              true,

		// Metrics
		"metrics.enable": true,
		"metrics.port":   true,

		// Cert Manager
		"certManager.enable": true,

		// Webhook
		"webhook.enable": true,
		"webhook.port":   true,

		// Prometheus
		"prometheus.enable": true,
	}
}

// GetValuePath retrieves a value from a nested map using a dot-separated path
func GetValuePath(values map[string]any, path string) (any, bool) {
	parts := strings.Split(path, ".")
	current := any(values)

	for _, part := range parts {
		if m, ok := current.(map[string]any); ok {
			if val, exists := m[part]; exists {
				current = val
			} else {
				return nil, false
			}
		} else {
			return nil, false
		}
	}

	return current, true
}
