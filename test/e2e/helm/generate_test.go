/*
Copyright 2025 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package helm

import (
	"path/filepath"

	"github.com/spf13/afero"
	helmChartLoader "helm.sh/helm/v3/pkg/chart/loader"
	"sigs.k8s.io/kubebuilder/v4/pkg/config"
	"sigs.k8s.io/kubebuilder/v4/pkg/config/store/yaml"
	"sigs.k8s.io/kubebuilder/v4/pkg/machinery"
	pluginutil "sigs.k8s.io/kubebuilder/v4/pkg/plugin/util"
	helmv1alpha "sigs.k8s.io/kubebuilder/v4/pkg/plugins/optional/helm/v1alpha"
	"sigs.k8s.io/kubebuilder/v4/test/e2e/utils"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("kubebuilder", func() {
	Context("plugin helm/v1-alpha", func() {
		var kbc *utils.TestContext

		BeforeEach(func() {
			var err error
			kbc, err = utils.NewTestContext(pluginutil.KubebuilderBinName, "GO111MODULE=on")
			Expect(err).NotTo(HaveOccurred())
			Expect(kbc.Prepare()).To(Succeed())
		})

		AfterEach(func() {
			kbc.Destroy()
		})

		It("should extend an initialed project with helm plugin", func() {
			initTheProject(kbc)

			By("extend the project by adding helm plugin")
			err := kbc.Edit(
				"--plugins", "helm.kubebuilder.io/v1-alpha",
			)
			Expect(err).NotTo(HaveOccurred(), "Failed to edit the project")

			ensureCommonHelmFilesContent(kbc, false)
		})

		// This test is to ensure that the helm plugin can be added to a project
		// that has already been initialized with the go/v4 plugin.
		// As the project is getting extended with webhooks,
		// it is needed to run the `kubebuilder edit --plugins helm.kubebuilder.io/v1-alpha` command
		// with ` --force` again to ensure that the webhooks are enabled in the
		// values.yaml file.
		It("should extend an initialized project with helm plugin and webhooks", func() {
			initTheProject(kbc)

			By("extend the project by adding helm plugin")
			err := kbc.Edit(
				"--plugins", "helm.kubebuilder.io/v1-alpha",
			)
			Expect(err).NotTo(HaveOccurred(), "Failed to edit the project")

			ensureCommonHelmFilesContent(kbc, false)
			extendProjectWithWebhooks(kbc)

			// after creating webhooks, we want to have the webhooks enabled
			// in the values.yaml file, so we need to run `kubebuilder edit`
			// with the --force flag for the helm plugin.
			By("re-edit the project after creating webhooks")
			err = kbc.Edit(
				"--plugins", "helm.kubebuilder.io/v1-alpha", "--force",
			)
			Expect(err).NotTo(HaveOccurred(), "Failed to edit the project")

			ensureCommonHelmFilesContent(kbc, true)
		})
	})
})

// ensureCommonHelmFilesContent tests common helm-chart files which got
// generated by the helm/v1(-alpha) plugin
func ensureCommonHelmFilesContent(kbc *utils.TestContext, webhookEnabled bool) {
	var helmConfig helmv1alpha.Plugin
	projectConfig := getConfigFromProjectFile(filepath.Join(kbc.Dir, "PROJECT"))

	By("decoding the helm plugin configuration")
	err := projectConfig.DecodePluginConfig("helm.kubebuilder.io/v1-alpha", &helmConfig)
	Expect(err).NotTo(HaveOccurred(), "Failed to decode Helm plugin configuration")

	// loading the generated helm chart
	chart, err := helmChartLoader.LoadDir(filepath.Join(kbc.Dir, "dist", "chart"))
	Expect(err).NotTo(HaveOccurred(), "Failed to load helm chart")

	// validating the helm chart metadata (Chart.yaml)
	err = chart.Validate()
	Expect(err).NotTo(HaveOccurred(), "Failed to validate helm chart")

	// expect the chart-name equal to the name of the PROJECT
	Expect(chart.Name()).To(Equal("e2e-"+kbc.TestSuffix), "Chart name doesn't match")

	// expecting the existence of a manager.yaml file
	var matchedFiles int
	for _, templateFile := range chart.Templates {
		switch templateFile.Name {
		case "templates/manager/manager.yaml":
			matchedFiles++
		default:
			matchedFiles += 0
		}
	}

	Expect(matchedFiles).To(BeNumerically("==", 1))

	// check if webhooks are enabled in the Chart.yaml
	if webhookEnabled {
		isEnabled := chart.Values["webhook"].(map[string]interface{})["enable"]
		Expect(isEnabled).To(Equal(webhookEnabled), "webhook isn't enabled in the Chart.yaml")
	}
}

// extendProjectWithWebhooks is creating API and scaffolding webhooks in the project
func extendProjectWithWebhooks(kbc *utils.TestContext) {
	By("creating API definition")
	err := kbc.CreateAPI(
		"--group", kbc.Group,
		"--version", kbc.Version,
		"--kind", kbc.Kind,
		"--namespaced",
		"--resource",
		"--controller",
		"--make=false",
	)
	Expect(err).NotTo(HaveOccurred(), "Failed to create API")

	By("scaffolding mutating and validating webhooks")
	err = kbc.CreateWebhook(
		"--group", kbc.Group,
		"--version", kbc.Version,
		"--kind", kbc.Kind,
		"--defaulting",
		"--programmatic-validation",
		"--make=false",
	)
	Expect(err).NotTo(HaveOccurred(), "Failed to scaffolding mutating webhook")

	By("run make manifests")
	Expect(kbc.Make("manifests")).To(Succeed())
}

// initTheProject initializes a project with the go/v4 plugin and sets the domain.
func initTheProject(kbc *utils.TestContext) {
	By("initializing a project")
	err := kbc.Init(
		"--plugins", "go/v4",
		"--project-version", "3",
		"--domain", kbc.Domain,
	)
	Expect(err).NotTo(HaveOccurred(), "Failed to initialize project")
}

func getConfigFromProjectFile(projectFilePath string) config.Config {
	By("loading the PROJECT configuration")
	fs := afero.NewOsFs()
	store := yaml.New(machinery.Filesystem{FS: fs})
	err := store.LoadFrom(projectFilePath)
	Expect(err).NotTo(HaveOccurred(), "Failed to load PROJECT configuration")

	cfg := store.Config()
	return cfg
}
